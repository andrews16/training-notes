~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 -------------------------   Week 1   --------------------------
 -------------------------    Java    --------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Topics:
* Basics 
* Variables
* Classes
* Methods
* Scopes
* Garbage collection
* Arrays
* Var args
* For each
* Access modifiers
* String StringBuilder/StringBuffer
* Exceptions
* Throw/throws
* Wrapper Class
* IO
* Serialization
* MAVEN
* JUNIT
* Unit Testing
* HashCode
* Object Class
* Short Circuit Evaluations
* Generics
* Collections
* Log4j
* Threads
	* Runnable Interface
	* Thread States
	* Synchronized keyword
	* Deadlock
	* Producer-Consumer Problem
* JavaStream


Abbreviatations used in this document:
ref : reference
val : value
rep/rep'ing/reps. : represent
prim/prmvt/ prm : prmitive
Above abbraviations are arbitrary; it's just how I take notes.

Class Notes: 
=================================================================
			  * Basics
=================================================================
Java:
>> Object-oriented
>> Statically typed programming language 
>> Automatic memeory management 
>> Write-once run-anywhere support 

Statically typed: Variables/fields don't change 
  - Once a type is assigned, it cannot be changed. 
  - This is for more predictable behavior / JDK suggestions.

Write Once Run Anywhere - Supported by the Java architecture (JRE)
 and the Java Virtual Machine. JVM/JRE Maintained by Oracle.
>JRE: software that launches the application
>JVM: the environment in which the applicaiton actually executes. 
>Oracle: (Originally Sun Microsystems) company manages Java
	> Manages compatibility between various OS/hardware.

WHY Java?
 - historically server-side language of the web. 
 - Huge share of the market  of server development. 
 - MANY existing work that is available to new developers 
	- Tools/apps to speed up proejct development & deployment
	- Tools called Frameworks. 

=================================================================
			* Variables
=================================================================

2 types of variables:
	1. Primitive
	2. Reference

==> Primitives: 8 Different  
Unlike refs, the data rep'ing the prim val is stored directly.
 - There is no refrence to another location. 
8 types, 4 categories:
Integer:					Literal:
	byte	8-bit, signed int
	short	16-bit, signed int
	int	32-bit, signed int
	long	64-bit, signed int		10L
Floating Point:
	float	32-bit precision
	double	64-bit precision		10.00d
Character:
	char	stored w/ 16-bit unsigned int	 'c'
Boolean:
	boolean	true / false logical

Note: If you try to shift a char to a short and it's int value is
	 greater than 2^15, the short won't be able to handle it.

>> Reference type variables store a reference to an object 
somewhere in the heap. The reference is used to locate that 
object. The STORED reference points to the object.

=================================================================
			* Classes
=================================================================
Every java class has a public class with the same name as file.
Every java program that is executable has a main method. 
Execution begins* at the main method. 
			     (* Generally, unless static block)

	public class NameOfFile{
	public static void main(String[] args){
	
	} 
	}



- When a variable is declared in a method scope, it must be
initialize by assigning a value before use.
	int myInt;

For INTEGER category
 > Can use underscores inside the number : easier to read!! 
	Rules: 
		can't start with _
		cant end with _
		_ can't be directly by the decimal

	long myLong = 1_234_567_890;
  ,--------------------------------^
Note : The L or d you technically only need if the number is too
 big to be represented by an integer literal:
	myLong = 123_234_456_567_098L;


=================================================================
			* Objects
=================================================================

>> Java is an object oriented programming language.
- Thus, much of programming and writing application in java
 revolves around defining class structure and then instantiating
 objects of those classes.
Classes are composed of |class members| which are the combination
 of fields and methods.
- Classes are Blueprints.

**Don't define classes inside the bracket of other classes.** 
- However, you can have other classes in the file of classes so 
  long as the file has another class named after the file.
- Fields in a class don't exist until an object of the class is
  instantiated.

>> Default Constructor
 - All classes are implicitly extended from the Object class.
 As extention of an Object, any class that does not define a
 constructor has a default no-args constructor 
				(inherited from the object class)
 Default constr. only available if NO other constr declared 
 If you want special no-arg constructor, MUSt be defined.
- Class Names Should Be Capitalized.

>> Default value
 - Fields in java get default values; all 0-like values.
	Boolean	  -> false
	Integers  -> 0
	Floating  -> 0.0
	Char	  -> character rep. of 0 
	Refrence  -> null

Note: Static fields also have these defaults.
>> No undefined in java, only null. 
- Primitives cannot be null.
=================================================================
		 * Constructors
=================================================================
- diff from methods, cannot be called directly. 
  -- Called when new object is created.
Signature of a constuctor is similar to that of a method, 
	but there are some KEY differences:
 - Constructors have NO return types (not even void)
 - Constructors only get access modifier keywords.
 - Constructor methods must have the same name as the class.

class Phone(){
	String brand;

	public Phone(){
// Calls the constructor defined with a string parameter.:
// So if you use Phone() constructor, it will direct the code
// to Phone("Samsung"); in this case:
		this("Samsung"); //Call other constructor.
//		super(); 
//The first line must either be super or call another constructor.
//If neither is used, Super will be called implicitly anyway.
	}

// Constructors can be overloaded (Polymorphism)
	public Phone(String brand){
		this.brand = brand;
	}
}

- Usually use either:
    -a constructor that takes everything 
    -or one that takes nothing. 
Less options is better for users, for the most part.

- Constructor is a method used to create an object.
- Constructors are NOT inherited. 
	- You MUST specify constructor in subclasses.

~~~~~~~~~~~~~~~~~~~~~~ * Methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Actions that can be done are generally described
 using methods. Methods contain executables that are related to
 object which can be called on an object instante.
	Static methods are owned by the class and should be called
 using the calss name rather than the object instance.

DRY. Dont. Repeat. Yourself. If you have to do something more than
once, probably make a method for it.

Components:
==> Method signature: 	
 - Minimum:
 returnType methodName(){}
	- Access modifiers are required for default access.
	- returnType or void if no retrn. 
 - Other keywords:
	- Access modifiers : private public protected
	- final : Not overridable
	- static : make method static
================================================================
			* Scope
=================================================================
When a variable is declared, it has a scope for which the variable
 is available and afterwards it is no longer available (the
 VARIALBE) is gone
Scope is about the VARIABLE'S own existence. 
- There is NO global scope in java.

1. Static Scope
	variables created when the class loader first loads the
 class. It will stay in scope as long as the class is kept in
 memory.
2. field sope - variable is declared as a field of an object. The
 field is accessible and in scope within the object within any 
 non-static context or via an object reference outside the class.
3. Function/Method Scope - any parameter defined on a method is
 accessible throughout the list of the method.

4. Block scoped - scoped to a code block. Any variable declared
 within a method is considered to have block scope. It will be
 scoped to the current code block.
	- Also you can arbitraritly add {} brackest around a code
 section to clear the memory for after it runs, that that is
 generally over-optimization and would be better off as a method
 called instead of a bracketed block.

==> Static variables assigned first
==> Then Static code block runs before the main method
	= Static blocks run in order top down.
==> Instance code block runs every time we use the constructor (see execution order.java)

================================================================
		* Garbage Collection 
================================================================
- How the JVM automatically manges memory.
>> First, unreferenced objects are identified and marked as ready.
 Their finalize() method is run. 
>> Second, they are deleted.
- Optionaly, existing heap memory can be "compacted" to one
 contiguous block at the start of the heap. This makes it easier
 to allocate memory to new objects; the JVM doesn't need to look
 for or sort through anything to get to the free space

- Subroutine occasionally run as necessary which clears up memory
 by removing objects which have no referneces pointing to them. We
 don't have a lot o control over the collection, but it will happen
 as we take up more and more memory.

- Let it do its thing be default.

- HotSpot - Oracle's JVM, the most common, with a large set of 
garbage collection options.
	- Implements generational garbage collection
	- Categorizes objects by age.
           v-----v-------------------------survivor space
    [eden](s0)(s1)<tenured>{permanent}    <--memory
    |---young----||--old--||permanent|    <-- generation labels

Heap's 3 Generations:
1. Young Generation: Newly created objects are placed here.
	Very minor event to clear items from young gen.
2. Old gen : Longer-lived items are eventually moved from young
	to old. Major event to delete these.
3. Permanent : Metadata (classes and methods) live here. 
	Not deleted by the garbage collector.

You can Suggest to JVM to run Garbage collection:
	System.gc() or Runtim.gc()

HotSpot has various garbate collectors:
	1. Serial : collection done serially, 1 thrread.
	2. Parallel : Multi threads run (Stops app)
	3. CMS : Concurrent Mark Sweep 
		- Parallel + allos application to be running
	4. G1 (Garbage first) - Newest made to replace CMS
This may be userful for server-side things.


================================================================
		 * Arrays
================================================================
Arrays represent an organized block of like types. Generally, we can assume that there is a relationship between the contained items.

declaration
int[] intArr = new int[size];

size of array is fixed and set upon creation.
for primitive types the array is iniialized with default values
for reference theyles the array is initialized with nulls

access to individual values is gained by using the [] and an index balue.
In java (and the majority of programming languages), index values begin at 0.
So for an array of 10 elements the range of valid indexes is 0-9.
Attempting to access an index outside of the valid range will result in IndexOutOfBoundsException

Arrays use {} curly brackets
INHANCED USE FOR LOOPS! WOW

for(int i: myArr){
	System.out.print(i + " ");
}
^^^^ VERY COOL GOOD YEA WOW USE THIS ALWAYS NEATO
i = myArr[1] then [2] and [3], ect.... 

=================================================================
		* Var Args - Variable Arguments
=================================================================
Variable arguments - allows us to declare a function which accepts a variable amount of arguments. The syntax is:
type... varName


What you get is an array of the given type whith th variable being the name.

public void list(int... myInts){
	for(int i : myInts){
		System.out.print(i + " ");
	}
}
>> Takes all items, wraps in an array, and provides them.

.printf accepts a string and wraps them into an array to use.

==> Multifunctional: You can have multiple things, so long as the var args is LAST in the method:
public void list(String message, int... myInts){}
- can't have multiple var args in a method, either.

==> You can make a main method with var args, sure. 
=================================================================
		* String manipulation:
=================================================================
.replace
.indexOf('e')
+ can privide a string instead of haracter.
+.indexOf("String")
.indexOf(start int,char)
.lastIndexOf('e')
.isEmpty() -- Boolean
.split(" ")
+ Splits string into array by a particular character.
.toCharArray()


=================================================================
		* StringBuffer & StringBuilder:
=================================================================
Strings are immutable.
However, StringBuffer and StringBuilder values can be changed.
- Useful if your string is changing a LOT
- Allows appending/inserting into the string.
- Since new strings aren't created (they're mutable)
  StringBuffer/Builders are less taxing on the memory
	- There will be less for Garbage Collection to clean up

Differences:
StringBuffer is "thread safe" thus operates a little slower.
	> You can use synchronize(StringBuffer name) {}
	but NOT on the -builder.
General rule:
	App with multiple threads : use stringBuffer
	Single thread : use StringBuilder(its faster)

=================================================================
		* Exceptions/errors
=================================================================

Errors - serious problems - we should not try to catch them.
Exceptions - we MUST handle in order to compile. 
	Must have explicit handling or declaration of the exception. 
Runtime Exception - does not need to be handled in order to compile the program.

==> Normal exceptions

Runtime Exceptions - come from logical problems so we don't need
 try-catch block to prevent them. They're far more frequent so
 requiring a try-catch block for EVERY one would be too much.
	- Runtime exception means FIX THE LOGIC.
	- Unchecked >> JRE can't "check" for them while compiling

(normal) Exceptions - cannot be predicted! These exceptions 
(non-runtime) are the result of external systems (IE Users or API
 connectivity). The error is not in the scope of the application.

** Mitch will type in the word cat to your program to see what happens.

Ways of handling exceptions:
	try/catch - handle it locally
	throws	  - Make someone else to it. (another method)

- After an exception, the code in that block is unreachable because
 the program doesn't know what to do with the information it has. It
 goes from the line that created the exception straight to the
 handler. 

throw, throws, throwable
Throw - keyword in executable code which throws an exception.
	- throw allows you to create a custom exception
Throws - declares within method signature that this method could
       throw an exception, and for the caller to handle it.
throwable - superclass of Error and Exception

Difference between final, finalize, and finally?
final - End be extended ( classes) cant be overridden (method) or
	 reassigned (variables)
finalize - method called on objects when garbage collected.
 (pretty much only useful for demonstrating garbage collection)
finally - code block associate try blocks that will always run. 
	100% will run. (unless system.exit)

COMMON Runtime Exceptions - Unchecked:
Casting : CastClassException
Collections : NullPointerException
	ClassCastException (Mess up autoboxing)
Arrays:	NullPointerException - when refrence on object is null.
	ArrayIndexOutOfBoundsException
IO (input/output) :
	java.io.IOException (general class)
	java.io.FileNotFoundException
	java.io.EOFException (End of file reached unexpectedly)
Serialization: java.io.ObjectStreamException (General)
Threads : InterruptedException
	SecurityException
	IllegalThreadStateException


===========* Checked vs Unchecked Exceptions================

	- Checked exceptions - non-runtime exceptions. Exceptions 
	we have to handle.
	- Unchecked exceptions - any kind of run-time exceptions 
		- you don't have to explicitly provide handling.

When to Checked Exceptions occur vs when do unchecked occur?
	- Checked exceptions occur in runtime.
	- Unchecked exceptions occur in runtime. 
	BOTH occur at runtime.
 
Runtime exception / Compile-time exception 
	:Misnomer... Inaccurate naming. Both occur at runtime.

	Checked exceptions are general ones - logic-created/syntax 
	Unchecked exceptions are runtime exceptions 
	- something you SHOULD logically work your way around.

CHECKED :
	FileNotFound
	IOException
	  > FileNotFound, InterruptedByTimeout, InterruptedIO,
	    InvalidPropertiesFormat, MalformedURL, ObjectStream,
	    Protocol, Remote, UnknownHost, UnknownService
	    UnsupportedDataType
	ClassNotFound
Unchecked : 
	Error
	RuntimeException
	   > Aritmetic, NullPointer,NumberFormat,IndexOutOfBounds

==================================================================
 		   * Wrapper Classes 
==================================================================

** probably get Mitch's code ** 
 - Recall the 8 primitives in Java.  They are not objects.
 - Object cannot work w/ primitives on their own
	They use WRAPPER classes.
	- Examples include java.util classes such as
	ArrayList, HashSet, Maps, and so on.
 - Wrapper class has the same unabbreviated name w/ Capital Letter
 - Contain useful helper functions.
 - Largely can be used like primitives.
 - "BOX" in Auto-boxing/auto-unboxing refers to the Object
==> Auto-Boxing: Process of automatically wrapping prim. val. 
	SomeClass box = new SomeClass();
	box.setContents(5); (SomeClass has primitive Object contents)
	box.getContents() instanceOf Object == true;
	Integer myInt = (Integer) box.getContents;
	print myInt will give you 5

==> Auto-Unboxing - Auto. extract/use wrapper class's inner prim.
	int primitiveInt = myInt (myInt was declared as Integer)

==================================================================
			* IO 
==================================================================
* I/O or * Input/Output

IO - Input/Output allows communication outside the application.
	- Read/write to/from files

- 3 main packages:
	io package  <-- The one we will work with for now
	nio package (new io)
	nio2 package (new io2)

 - Exceptions : Most fall in broad IOException class.
 - External resources : close resources when done.
    -> Use try-with-resources to open then close file after block
	try(IOClass name = new IOClass(constructor arguments)) {
	} catch (IOException e) {}

==> OutputStream utility:
	- Abstract class representing an output stream in bytes
	- Subclasses of OutputStream must privode @ least 1 method
	  that writes one byte of output.
 >> InputStream and OutputStream classes have subclasses:
	File(In/Out)putStream
	ByteArray(In/Out)putStream
	Filter(In/Out)putStream
	Object(In/Out)putStream
 >> The Filter(In/Out)putStream Class has two Subclasses:
	Data(In/Out)putStream
	Buffered(In/Out)putStream


==> Classes to Write Files
 - FileOutputStream
	- subclass OutputStream object; requires # of bytes to read
	String data = "yourData";
	File somefile = new File("Path");
	try(OutputStream os = new FileOutputStream(somefile)){
		os.write(data.getBytes(),0,data.length());
	} catch (IOException) {}

  FileOutputStream To object:
ObjectOutputStream oos = new ObjectOutputStream(FileOutputStream(file)))

 - FileWriter:
	- Simplest way. Writes int, byte arr, and string directly
	- Need to write a loop to write the file line-by-line
	- Requires input of # of bytes to write each time
 - BufferedWriter 
	- Like FileWriter, but uses internal buffer to write data.
	- Better for multiple write operations
try(BufferWriter br = new BufferWriter(FileWriter(File(file)))){
	//for loop to run through lines youd like to write
	} catch(IOExceptions) {}
 - Files Utility
	- Can write file using its write function.
	- Interally it uses OutputStream
	Try {
	Files.write(Path.get("path here"),yourDataHere.getBytes();
	 } catch (IOException e) {}

==> Classes to Read Files
 - FileInputStream
 - FileReader
 - BufferedReader
 - Files Utility
 - Scanner Class

  >> Use FileInputSteam, FileReader,BufferedReader
	1. Set up the try just like for writing but with the
	 input/reader class
		- BufferReader/FileWrite require a # of bytes
		  to read and must loop through/append a string
		- Also should check is the next line is null
	2.  Be sure to assign the result to something
	
  >> Use Scanner class:
	 File file = new File("Location")
	try (Scanner sc = new Scanner(file)){
		while(sc.hasNextLine()) {
		// put the info somewhere. }
		sc.close();
	} catch (IOException){}

	OR WITHOUT LOOP:
	sc.useDelimiter("\\Z");
	System.out.println(sc.next());

  >> Use File Utility:
	- Comes with a handful of ways to read file.
	- Benefit - you don't have to close the resource, its auto

==> Exceptions
	IOExceptions:
	  - Most common : FileNotFound
	  - Often will need to catch the ClassCastException
	  - List of a few other possibilities:
	  > FileNotFound, InterruptedByTimeout, InterruptedIO,
	    InvalidPropertiesFormat, MalformedURL, ObjectStream,
	    Protocol, Remote, UnknownHost, UnknownService
	    UnsupportedDataType



==================================================================
			* Serialization
==================================================================
Serialize (v) :
	1. publish or broadcast in regualar installments.
	2. arrange (something) in a series

 - Serialization is the process of translating data structures or 
   object states into a format that can be stored/transmitted
   and reconstructed later.

 - In java, Serialization writes the object state to a file as
  Java bytecode, and it cannot be used outside a JVM.

Reading/Writing OBJECTS:
 - If using (IO)Stream, use subclass Object(In/Out)putStream.
 - When getting data back, you need to CAST the data
   as the type you want it when you store it on your variable.
 - Object must be Serializable in order to be read/written.
	Serializable is a marker interface: 
		- it has no methods
		- It is used to define a class for external source
	- To be serializable, all firleds must also be serializable
	- Not serializable fields need to be marked "transient"
		- Useful for data that doesn't need to be saved.

UID - Number used to represent different stages of an object's life
   - To utilize this, you must commit your files upon each update
   - If the object on file has a different UID, it may be missing
     information that your newest object do have. 

 ==================================================================
			* Maven
 ==================================================================
Maven (Apache Maven at maven.apache.org ) is a software management
and comprehension tool. 
>> Library of Frameworks that are open-source to help developers
   with applications.


==================================================================
			* JUNIT / * J-UNIT
==================================================================
Maven framework.
- Assertions are used to test applications
- Using an assertion we state out expectation for the behavior of 
  the code.
- If the expected behavior occurs, then the test passes.
- If the behavior does not match our assertions then the test fails.


==================================================================
 			* Unit testing
==================================================================
there are many kinds of testing unit testing is the most basic and
focused method of testing in software development this testing tests
individual units of code on the smallest possible scalre. generally
this means testing the behavior of individual methods.

this often involves the process of mocking. many methods or classes
maybe dependant on other methods/classes. To test in isolation, we
oftne mock these dependencies with fake implementations so that our 
tests only cover the individual unit. 
JUNIT alone isn't enough for unit testing. Mockino is a good tool
 that builds on junit.

Unit testing focuses on one method at a time. Shows in which 
behavior exactly the method is failing.

Good practice to write tests for all completed methods.

TDD - test-driven development.
Write test first, then implement behavior to implement functionality
 until all tests pass.
Assert behavior first then create it.

J-UNIT = someone else's java application.
Dependencies means an external java application. Someone else's code.

Keywords : @Before
@BeforeAll
@After
@AfterAll
@Test


==================================================================
		* Reflection 
==================================================================

Frameworks are written using Reflection.
It uses abstract coding so that it is flexible yet functional.
Reflection looks at classes as objects to manipulate code.


==================================================================
                      * Hashcode
==================================================================
- Object-class method: ALL Classes have a default.
- Assigns each instantiated object a code based on their data.
- IF dev. plans to override hashCode, a CONTRACT must be followed:
	1. If 2 objects are equal, they have the same hashCode.
	2. If 2 objects have different hashcodes, they're not equal
- Generally best to define .equals() then auto-generate .hashCode() 
- Implies objects of different classes CAN have the same hashcode
- Hashcodes can be different on different application runs.

- Comparing hashcodes is quicker than .equals().
Trivia:
- Technically a "native" method - meaning it was written in an
  operating system language and implemented directly into the JVM.

==================================================================
		* Object Class
==================================================================
- Object is the superclass of all Java classes. 
- ALL classes/objects inherit Object class methods:
	.equals(Object o)
	.getClass()
	.hashCode()
	.notify() <used in sync threads
	.notifyAll() ''
	.toString() Convert object to string
	.wait()
	.clone() < return new object exact copy of calling
	.finalize() <auto-called before object is garbage collected

==================================================================
 		 * Short Circuit Evaluations 
==================================================================
	
||, && 		<---short circuit operations
    If the application can descern wherethera || or && statement
    is true/false by the left side, it wont look at the right.
		true || ___never evaluated___
		  OR
		false && ___never evaluated___

ALWAYS check/run full operation: use SINGLE operation:
Non short-circuit:
|, &   <------- not short circuit operation.

		true | __runs this statment__
		false & __runs this statement__

Reason for Shit-circuit evaluations:
  - Efficiency. 
  - Some expressios may require expensive/long-running ops.
  - Convenient way of avoid exceptions.

 ==================================================================
			 * Generics 
 ==================================================================
- Using the type Object will allow us to hold a reference of ANY
  type. However, we rarely know what type is actually being held
 in it at any given time. 
- Largely, it is then left to the programmer to determine what type
 was placed in or what type could be in it. This dangerous and
 requires a lot of explicit type casting and can be frustrating.

GENERICS solve problem
- Generic solve this by allowing us to write a class in a generic
 way that could utilize many different types, and provide the types
 information to the class (or method) upon creation.

  "Writing on the box on the outside what should be contained in it"

- Generics bring "compile time type safety"

- if we try to use the wrong type with generics,
  it wont let us do it.

- Syntax for generics will generally include angle brackets <>
- Type information is generally provided within angle brackets.

To MAKE a class Generic: 

public class <T> Box {
}

-can use <T extends SomeClass> as well.
- Can create generic methods, too. 

Example, they extend the class "printable" and upon calling the
 method, the user can choose what data type will be sent in and
 returned.

public void genericPrint(T toPrint)<T extends printable> {
system.out.println(toPrint);
}

or to return a type T:

public <T> genericMethod(){ .. }

-- Limited on what you can do. 
generic method call:
myStringBox.<String>genericPrint("A String.");

==================================================================
			* Collections
==================================================================
- A collection is like a flexible arrray for objects. 
- Collection is a java interface implemented by all collections 
  which contains static methods used to manipulate the collection

Common Methods:
	.add(Object)
	.contains(  )
	.remove(index)
	.size();  <- collection version of length()
		ALL collectionsare flexible in size.

Class Tree: 
	 ___________Collection ____________________
         |                |                       |
________Set	         List	 	        Queue
|(sorted)   		  |		        |
|-HashSet   		  |-LinkedList----------|
|-LinkedHashSet           |-ArrayList           |-PriorityQueue
|(not sorted)		  |-Vector
'-TreeSet		  

SET : 
	- May not have order
	- Sets contain no deplicate elements. 
	- Duplicate is determined by the "equals" method
		- User can, of course, override this in the class

LISTS :
	- Can have duplicate elements
	- Have some kind of order.

QUEUE :
	- First in, first out.

ArrayList vs Linked List
	- ArrayList is stored like an array
	- Use ListIterater for dynamic add/removal of items.
	- LinkedList objects operate like a queue, somewhat
		- Items have refrence location for themselves
		- and to the locaiton of the previous and next 
		  elements in the linkedlist
	- Array list is better if you need to just grab items
	- Linkedlist is quicker to process for adding/removal

The implementations of these lists are different which means
 internally, they preform differently. However, since we will 
 reference them using the List infterface, our code will treat them
 identically. 

==>Iterating over Collection: & ConcurrentModificationException
	- You cannot iterate over a collection in the typical way.
	EXCEPTION will occur if you delete/add element:
	ConcurrentModificationException
	- Because odifying list while iterating over it causes
	  java to not know
	- Instead use the Iterator object and enhanced for loop:
	CollectionType<Obj> myCollection = new ______<>();

	Iterator<Obj> iter = myCollection.iterator;
	for(iter;iter.hasNext();) {
		Obj something = iter.next();
		iter.remove();
	}



==================================================================
 		* Data Structures (Basics)
==================================================================
Main classes of data storage structures:
[Collection]
	<<List>>
	<<Set>>
	<<Queue>>
<<Stack>>
<<Map>>

==> Stack : Last-in-first-out stack of objects.
	Extends Vector Class
	Used for temporary data/quickly changing
==> Map : Key-value paid data storage. Separate from Collection.
	- Instantiating Map gets 2 data types
	Map<String,Integer> myMap = Map<>();

Important types of Maps:
- HashMap:
	- Faster, good for single-thread apps.
	- Can have null values (1 null key max, any null paired val)
- HashTable :
	- Can be used in multi-thread applications
- TreeMap
	- Sorted version of HashTable
Map Methods:
	.put(key,val) Puts val into key, return old val if present
	.get(key)  get val at key
	.remove(key)  removes val, leave key
	.keyset() returns set of all keys in map
	.values() returns set of all vals w/o keys

Iterate over map:
Use .entrySet() method to get Set of each map entry.

Then iterate over the Set with an enhanced for loop:
for(Map.Entry<Object,Object> entry : map.entrySet()) {...}



 ==================================================================
			 * Log4J  
 ==================================================================


create file in source/main/resources named log4j.properties
- java properiettary java format for describing key/val pairs or posibly arrays
put some kind of key in followed by the format.
when you try to acces the values, it goes through the application.

>> Know that they work... Required to get logging working.

Logs can be written to other file to look at later.

Really inportant for server applications... We won't have access 
directly to the console so we have to have logging files to figure
 out what happened.

org.aoache.log4j2.consoleappender to console
''  '' ''' '''  .FileAppender logs to append a file.

>> No system out after console project... just change logging level
   to see less. 

in log4j2 properties, the line:
rootLogger.level = debug
can e changed to show which level of errors to actually log. 

Memorize logging levels. 

ERROR - fatal error/exception
WARN - WARN of potential problem
INFO - what we want to know looking at files 
DEBUG - message we rarely turn on



 ==================================================================
 			 * Threads 
 ==================================================================
- Processing multiple sections at the same time.
- Multi-threading increases the complexity of the application.
- Threads introduces unpredictability.

There are many ways to create mlti-threading, but here are two:
Thread class
Runnable interface.

Thread Class : 
 - Contains many methods.
 - first override run method.

>> "Main method" of your launcher, for example, is one thread.
  - Other threads are technically not a part of the main thread.
    They start by executing their own run() method.

The "run()" method does not start a thread.
	We override run, but we don't call run.
	>> Calling run doesn't start a new thread.

.start() Method does start a new method.
	Thread class gives you a ton of power to override all 
	kinds of things. More specifically, the power to override
	stuff you really should not override.



==>* Runnable Interface:

Runnable is a * Functional Interface.
It contains one abstract method : run()

>> Functional interfaces have exactly 1 abstract method.
 (Marker interface - no methods, used to categorize/mark a class)

* Lambda Function and the Functional Interface:
- The Lambda function can only be used with functional interfaces.
- It is a shortcut to setting the abstract method without using
  the overide keyword.
Runnable myRunnable = () -> System.out.println("new run() method");

Since functional interfaces only have one abstract method, this
is used in place of a constructor and creating a whole class.

==>Atomic Operations - something that happens in isolation.
	- An atomic operation is a SINGLE operation.
	- For example: a = 5;
	All it does is assign 5 to a.
w/ multi-threads, it is often important that if a thread accesses
 a variable, its changes aren't overridden/ignored by another.
  -AtomicInteger solves the problem.
	int a =5;
  -a++ is NOT atomic because JVM has to get a THEN add 1.
	AtomicInteger a;
	a.incrementAndGet();
   - Now any thread that accesses a will get the same value, and
     every thread's increment will be reflected.

==> * Thread States
 Thread states detail current state thread is in.

1. NEW - New state upon creation, until started. 
	- Thread myThread = new Thread(myRunnable);
2. RUNNABLE - Thread eligible to run, may or may not be running
3. TIMED_WAITING - stopped/waiting for specified amt of time
4. WAITING - stopped/waiting unspecified about of time.
5. BLOCKED - Blocked from proceeding due to a lock
6. TERMINATED - Thread has completed run method & is dead.


==>* Synchronized keyword:

synchronized keyword can be applied to a method or code block and
 it essentially states that the contents of it should be accessible
 to only one thread at a time. 

This means when a thread calls the method or enters the code block,
 it acquires a lock, preventing other threads accessing it until it
 surrenders the lock. This renders waiting threads into the blocked
 state.

-- Declare a method as synchronized after access modifier.
-- You can't choose what order the OS lets threads access the function.

==> * Deadlock		 ** Interview Question 
 	> Two threads waiting for eachother to finish in order to 
	  continue. 
	>> Often by complete random chance. 

- Method acquires lock for one object, and needs the lock for 
  another to proceed.
- another thread holds the lock for that other object, and needs
 the lock for the first one object to proceed.
 - Both threads are dead. Neither will be able to proceed.

TO AVOID: 
Provide a consistent order for which the locks can be acquired.

- Deadlock is a common problem in multithreaded applications.

==> * Producer-Consumer problem
- Example of multi-process sync (multi-threading) where 2 threads
  are utilizing the same data set (IE Buffer)
	-"producer" - adds data
	-"consumer" - removes data 1 by one
- Producer shouldn't ADD data if buffer is full
- Consumer shouldn't TAKE data if buffer is empty

SOLUTION:
Producer either:
	(1) Producer sleep if buffer is full
	(2) Producer discard data if buffer full
- When consumer takes data, producer is notified to fill buffer
- Consumer sleeps if buffer is empty
- Producer wakes up consumer when buffer has data

In java:
SEE:
https://www.javamex.com/tutorials/wait_notify_how_to.shtml
 - Producer/consumer are threads..
 - wait/notify methods.
 	- Wait puts object to "sleep"
	- Notify "wakes" it up

To use:
- Object must be synchronized to use wait/notify:
	[Lets imagine the producer has a List, applesBasket.
	The consumer .removes an apple from the basket]

- When tell a thread to WAIT, it temporarily releases it's lock 
  on an object while waiting for "notify()"
	[The consumer thread has getApple() in it's run() method]

public void getApple() throws InterruptedException{
	synchronize(applesBasket) {
		while(applesBasket.isEmpty()) {
			applesBasket.wait();
		}
		applesBasket.remove(0);
	}
}
	
- The producer thread can access the object while the consumer
  thread is waiting.
	[The producer thread has addApple() in it's run() method]

public void addApple(Apple newApple) {
 	 synchronized (appleBasket) {
   		 appleBasket.add(newApple);
  		 appleBasket.notify();
 	 }
}

- Notify means:
	"if there is at least one thread waiting on this object,
 	please wake up ONE of those threads."
- After calling notify, we should exit the synchronized block as 
  soon as possible, as that thread will need to reacquire it's lock

NotifyAll() wakes up all waiting threads for that object. 
Use notifyAll() if you don't have a very specific set of logic 
 -- notify is used above because the producer and consumer
    take and add the exact same amount of apples each turn.

 ==================================================================
			* JavaStreams 
 ==================================================================
JavaStreams allow manipulation of strings as if they were arrays.
Strings can be added, removed, searched for, or instered, plus more
List<String> myList = new ArrayList<>();
String str = "the quick brown fox jumped over the lazy dog";
String[] words = str.split();
myList.addAll(Arrays.asList(words));

myList.stream().forEach(System.out::println);

Function Interface - Accepts an input and returns an output.
Predicate - accepts an input and returns a boolean
Consumer - accepts an input and returns nothing.
Producer - Accpets no input and returns something.

- Give a convenient way to write concurrent programming.

Can use "parallelStream()" to create new threads operations... Which
 can be convenient threaded solutionsfor functionsthat would 
otherwise be difficult to process.









