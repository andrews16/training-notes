Contents:
I. HTML/CSS Quick Review
II. HTML
III. CSS
* Bootstrap
IV. Javascript
V. Java & Connecting
====================================================================
		   I. HTML / CSS Quick Review
====================================================================
--------------------------------HTML--------------------------------
- stands for HyperText Markup Language 
- HTML5 (newest version) maintained by W3C WorldWideWeb Consortium.
- Purpose: a symantic language used to describe content.
	- Is interpreted by browsers.
	- is structured by tags
- An element is the documents' representation of the tag and content
- Structure of HTML Document:
	<!DOCTYPE html>
	<html>
	  <head></head>
	  <body></body> 
	</html>
- Rules : 
	- Tags should be void, self-closing, or closed. 
	- If tag is opened within another tag, it must be 
	  closed before another tag closes.

- Attributes: Details about the tag and value.
	Examples: 
		src = "url" Loads external resource
		type, class, id, width, height, href

- DOM - Document Object Model
	- Tree Structure representing the document

			html
			 |
  .-------------------------------------.
  |					|
 head 	                               body
  |          	.---------------------------------------.
 meta		|			|		|
              header          	     article          footer 
         .-----'-.          .-----------|----------.      \
        h1      nav       header     section     section   div 
                          |        / |  |  \ \ \ 
                         ol       h2 p1 h3 p p p 
                        / | \
                      li li li

 --CSS also operations on this tree structure. 
	- This is how it knows which elements to select as children
 body nav {} //searches the body for navs underneath it to affect.

==> Common Tags
> Text
   h1 : header is a primary element used to describe main header 
	regardless of HOW we want it displayed.
   h2-h6 are subheadings
   p : paragrpah
   strong : increase weight of line
   em : italics
>Lists
  ol : ordered (numbered) lists
  ul : unorderd list
     li : list item (nested within list)
  dl : dictionary list
	dt: definition text
> Table
    table
	thead (semantic)
	tbody (semantic)
	tr
	  th
	  td
> External resource
   a (anchor)	<a href="url">Link </a>
   img (image)	<img src="url">
   script (javascript) 
	<script src="url"></script> or <script>JS</script>
   link <link href="css sheet" ref="stylesheet">
>Arbitrary structures (No semantic meaning)
	- Only use if you have no better way to describe the content
	- IE if structure is only for visual reasons.
  div : Block
  span : Inline block
> head
	Link
	meta
	title
> Input
form (Group of inputs that would be sent together.)
	<form method="" >--"get" or "post"
 <fieldset>
	<input type = "..." >
 types : text, button, color, number, check, radio, select, 
         datepicker, password, hidden

--------------------------------CSS--------------------------------
CSS stands for Cascading Stylesheet
- Provides styling rules 
	inline, in style tag, or in a link(extenal)
- Best to use as external
 Form: 			Selector{ property:value;}
 Application:	a {  
		   color : blue; 
		}

==>Types of identifiers:
1. Tag -> h1 {}
2. Class -> .someClass{}
3. Id -> #someId{} 


==> Selector : 
.class1 .class2{} -- "descentant of the element to stylize"
 		  -- selects all class2 in any class1
.class2,class1{}  -- "and" 
		  -- selects both class1 and 2
.class1 > class2{}-- "direct parent of the element to stylize"
		  -- Selects class2 that is a direct child of class1
.class1.class2{}  -- selects only elements with BOTH classes
h2#id		  -- Selects h2 element with the ID my-header

==> Display
block:   by default fills width, creating block on its own line
inline:  diplays on a baseline by default only large enough to
	 fill contents. Can be chained together(potentially 
	 changing the baseline)
flex:    Used to align items/show them in particular ways. 
inline flex, inline-block bombine features

==> Box model
 _ _ _ _ _ _ _ _ __ _ _ __ _ _ _  
|_________________________ Margin|
|| ________________ Border|      |
||| _______ Padding|      |      |
||||Content|       |      |      |
||||_______|       |      |      |
|||________________|      |      |
||________________________|      |
|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |

- Units of size:
%, px, em, rem, vh, vw, vmin, vmax

- Colors:
Literal - (blue, red, ect)
hex - #RRGGBB with each character being 0-f representing 256 vals
rgb / rgba - (n,n,n{,0 <= a <= 1}) where n = [0,255]
hsl([0,255],%,%);

====================================================================
			   II. HTML
====================================================================
------- Vocabulary -------
Tag - keyword used as syntax to organize and label types of content
      on a page
    - Tags are contained within right angle brackets < and >
    - Beginning tags include the keyword and may include other
      properties.
    - End tags are created with the tag name in angle brackets
      preceede with /
    <tag property="value"> content </tag>
Self-closing Tags - Do NOT need closing tags. 
       Examples: <img> <input> <br> <hr>
        TRIVIA - you used to be told to use <br /> to signify the end
	of self-closing tags before 2009 when they threw out XHTML 
	guidelines
Element - A beginning tag, matching end tag, and the content between.
Attribute - a property/value pair given to an HTML element.
     <tag attribute> Content </tag>
      Attribute syntax is property="value"
Property - keyword describing characteristic an element may have
Value - the assignment given to a property
Server - centralized computer which manages website or application 
       by sending information to client and processing requests
----- HTML Elements ------
+ Heading-Related tags
  <heading> </heading> 
  Syntax tag to describe which part of the document is the heading
  <h1> <h2> ... <h6>
  h1 is a main heading
  Proceeding h#s are subheadings
  By default, h1 has the largest sized font, and the font size decreses

+ List-Related Elements
  <ul>  Unordered List (Not numbered/Bulleted list)
  <ol>  Ordered List (Numbered List)
  <li>  List Item

+ Basic HTML Requirements
<!DOCTYPE html5>          
<html>
   <head> .. </head>
   <body> .. </body>
</html>

+DOCTYPE tells the browser it is getting an HTML page.
    This is not required always - a browser will "guess" usually that 
    a file is html correctly - but is proper to use it.
<HTML>   element contains all other HTML elements
<head>   Contains page metadata such as the tile of the page, CSS
	 scripts to link, and a description to give search engines. 
         This isn't required to have information in it.
         <title>Page Title</title> is often the bare minimum
<body>   Contains the visible content of the page in the view window.

+ <div> and <span> 
 <div> is a block element that may have arbitraty content.
       In HTML5, usually <div>s are replaced with more descriptive 		Semantic elements
 <span> is an inline-block element by default

-- BLOCK elements by default take up 100% the width 
         of their parent containing element.
-- INLINE-block elements stay in line with the text around it, 
       by default taking up only as much space as the content inside


+ Semantic Elements
   Semantic elements are blocks to label the content and for styling purposes.
	Examples:
	<header> , <main> , <footer>
	<section> , <article> , <summary>
	<nav>

+ Table-related Elements
  Tables are formatted, generally, as follows:
<table>
   <tr>
     <td> </td>
     <td> </td>
   </tr>
   <tr>
     <td> </td>
     <td> </td>
   </tr>
</table>

	<table> is the element declaring there will be a table.
	<tr> signifies a table row
	<td> signifies cell - table DATA - within the row from left to right.
	<th> is a table head cell which formats a cell

TRIVIA : Other table elements (probably youll never need):
<thead> <tbody> <tfooter>  Sematic elements to organize a table.
<caption> Place between the final </tr> and </table> to give it a 
caption By default 

====================================================================
		   	II. CSS 
====================================================================
CSS = Cascading Style Sheet used to stylize HTML elements.
+ Current/Newest version : CSS4
    We have been using CSS3 (it is most popular now)

----- Vocabulary ---------
Selector - The element within the HTML you are selecting to stylize
         3 types of selectors:
	  1. Tags
	  2. Class
	  3. ID
Class - identify a group of elements on a page 
	-- can be used mutiple times
	Elements can have multiple classes.
	In CSS you select by class with .ClassName
ID  - Identifies a specific element 
	- each ID should only be used once.
	In CSS you select ids with #IdName
** Classes/ IDs defined in the HTML.
+ How to insert CSS?
 1. Inline CSS - as a property to the HTML
    <tag style="attribute:value;
 2. Internal - usally placed in the <head>, but work anywhere.
    - CSS Contained by <style> .. </style> tags
 3. External stylesheets
    Must use HTML tag link to include external stylesheet:
<link href="./css.css" ref="stylesheet" type="text/css">

  Note above is default order of priority for CSS styling.
  You may also use !important to put a specific style to the top 
     of the priority list. For example:
	p {
    	   color: red !important;
	}

+ Colors
Main ways to identify colors:
  1. name  -- IE red, black
  2. Hexadecimal -- #RRGGBB
      RR GG and BB are red, green, or blue values 
      from 000000-ffffff (0-9 then a-f for each digit)
      00-ff corresponds to an RGB value of 0 to 255.
  3. RBG -- rgb(100, 100, 100)
      Numbers are R G B values of 0 to 255.
  4. RGBA -- rgba(100,100,100, .5)
      First 3 are the same as RGB, but the third value is ALPHA
      Alpha is an modified from 0 to 1 corresponding to % opacity

+ The Box Model
 The box model describes layers of space around the content which
 can be stylized.
 _ _ _ _ _ _ _ _ __ _ _ __ _ _ _ _ 
|_________________________ Margin|
|| ________________ Border|      |
||| _______ Padding|      |      |
||||Content|       |      |      |
||||_______|       |      |      |
|||________________|      |      |
||________________________|      |
|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |

 - Margin 
	-the outer layer
	- it is the space between one element and the next.
   	- vertically collapsable:
	  >> two blocks with margins, one  directly above the other, 
   	  will have the distance of the largest margin of the two 
          between borders.
- Borders is the layer between the margin and content,
    usually the area what has a border, if specified.
- Padding is the space between the content and the border.

+ Box-sizing
Typically, the width and height of a block are defined by the content.
   Padding, border, and margin are added on top of that.
The property box-sizing can specify if you want a height/width
property to be a "content-box" or a "border-box"

+ Selectors
  HINT: the type of element closest to the braces 
        is usually the one that will be stylized.

[space] "descentant of the element to stylize"
        .class p {};  will stylize all P anywhere in class even if
		      they are further nested
  >     "direct parent of the element to stylize"
         nav > a {};   "nav, the parent of the element to stylize, a"
                        so this will stylize all a that are direct 
		   	children of nav
  ,     "and"
         div,span,header{};    will stylize div, span, and header.
[no space]	Items to stylize is described with both
	tag.class{}    will stylize tags with the class 'class'
	tag#ID{}       will stylize tags with the ID 'ID'
 
+ Forms
Basic Outline of forms:
<form>         
      <label for="input1">Input One </label>
      <input name="input1" type="number" />
      <label for="input2">Input Two </label>
      <input name="input2" type="Text" />
      <input type="submit" value="Go!">
</form>

	Form tag organizes groups and inputs. 
  It tells the browser that the contained inputs and submit button 
  are all related and should be set to the server at the same time.

  Forms are blocks and can have attributes such as width, height, 
  and background.

  Elements that are typically in forms include:
<button> <label> <input> <fieldset>

+ Variables

To use variables, right create them with the .root selector. 
Variable names start with "--"
   .root{
	--text-color:blue;
	--div-bg:yellow;
   }

To use them later, use var(--name)

   div{
	color: var(--text-color);
	background-color:var(--div-bg);
   }


===================================================================
			* Bootstrap
===================================================================
Getting started: 
http://getbootstrap.com/docs/4.1/getting-started/introduction/

Components : Pre-styled code blocks for a feature
=>Types of Components
Alerts : Text that you can have pop up with optional close buttons.
Carousel : Slide images or things, may includes arrows to switch
	 left/right, captions, different fades.
Buttons : Generally nices looking for buttons.
Navbar : Basic with or without dropdowns
Cards : Very common tool (image with text)

Layout >> Grid:
	- Built on flexbox to be more responsive.
	- Create a container class.
	- inner div specified directly.
	- Inner inner is the content.

In flexbox, page is gridded in 12ths.
<div class="container">
        <div class="row">
            <div class="col-6"></div>
            <div class="col-2"></div>
            <div class="col-4"></div>
        </div>
        <div class="row">
            <div class="col-1"></div>
            <div class="col-10"></div>
            <div class="col-1"></div>
        </div>
        <div class="row">
            <div class="col-4"></div>
            <div class="col-4"></div>
            <div class="col-4"></div>
        </div>
    </div>

Bootstrap Forms are quite common now
- Most modern websites user bootstrap or Google Material Design.

Modals - used a lot for ads (cover screen until it is taken care of)
  such as terms of conditions.

===================================================================
===================== III. Javascript =============================
===================================================================
Javascript History:
	- Orignally created by in 1994 Bredan Eich for new browser
	- Named to piggyback on Java's success
	- Maintained now by ECMA 
	- Purpose : Accessible tool to connect HTML to components
	- Dynamic, weak-typed, prototype-based
	- Can be used like java for applications beside websites

===================================================================
		    * Variables
===================================================================
==> Declaring a variable:
	There are 3 ways to declare a variable:
  1. let myVar;		-Block scope, reassignable variable
  2. const myVar;	-Block-scope, constant (can't be reassigned)
  3. var myVar;		-Hoists variable, reassignable
  4. myVar;		-Creates global variable
==> JS Types
- Weakly Typed : JavaScript variables can be declared without first
	determining the type. They can be reassigned any other type
	without casting issues.
- JavaScript Types
1. String 	- 'single' or "double" quotes work.
		- use \' or \" for quote character
2. Number	- ONLY numberic datatype in JS
		- Floating-point number
3. Boolean	- true/false. Does NOT correspond to 0 or 1.
4. Undefined	- Default
5. Null		- Never assigned by JS
6. Symbol	- Represents unique ID
7. Object	- Holds key/value pair (like Java map)
8. Function (NOT a datatype, but a type)

Declaring functions:
	function myFunc() { ... }
	myFunc = function() { ... }
	let myFunc = () => {...}

==> Scope
1. Global Scope
	- Anywhere in the document the variable can be used.
	- Variables defined without let/var/const become global
	 --they can be used anywhere, even if defined in a function
2. Local Scope / Block Scope
	- Scope within control-flow statement or {}
	- let and const are block-scope
2.5. Function Scope
	- Functions create their own local scope:
	- variables defined with let,var,or const inside a function
	  are not available outside the function
   Example:
	function func() {
		let a = 1;
		const b = 2;
		var c = 3;
		d = 4;
	}
	func();
	a; //error, a is not defined
	b; //error, b is not defined
	c; //error, c is not defined
	d; //4

- Hoisting 
	Hoisting lifts the variable declaration to the top of it's
 scope. This occurs when variables are defined with var&no keyword.
 Example:
	{ {var x = 5} }
	x; //5
===================================================================
		    * Truthy-Falsey
===================================================================
- In Javascript  every value can be evaluated for truthiness. 
- Any value of any time can be utilized in an if statement, a 
  logical argument, ect.
- Most values are considered "truthy", but certain values are falsy
Falsy:
	"" (empty string), 0, null, NaN, undefined

- We can utilize these conditional statements in assignment.
- The variable will be assigned the VALUE that made the difference 
  in the result. 

const y = 0 || x;
		 result >> y = x
const z = NaN && x; 
		 result >> z = NaN

- Useful to resolve if something might be null.

-- Boolean expressions in JavaScript don't necessarily evaluate to a
 true or false value, but instead evaluate to the value in the 
 expression that made the difference in the resulting logical result.
- The logic of this follows short circuit logic closely.

===================================================================
		    * Template Literals
===================================================================
- ES6 Feature of JavaScript. 
- Used for formatting strings, often in place of contatenation

const person = {
	firstName : 'Abby',
	lastName : 'Adams',
	age : 22
};

//We want to print out "my name is Abby adams and I'm 22 years old.
////Concatenation method: 
const str = "My name is " + person.firstName + " " + person.lastName + " and I am " + person.age + " years old";
console.log(str);

// Template literals allow for simpler variable injection.
//////Tamplate literals method
let template = `My name is ${person.firstName} 
${person.lastName} and I'm ${person.age}
 years old.`

//` is a backtick, not a single quote 
//Template literals allow you to throw line breaks in there.
// Break provides actual linebreak. 
//You can escape that with a single backslash where the lines are:

template = `My name is ${person.firstName} \
${person.lastName} and I'm ${person.age}\
 years old.`

==> Arrays
- Can be variable in size and hold any datatype.
- Type of Object, can act like an object as well.

x = [1,2,3];
x[-2] = 'cat';	//<--------------Acceptable declaration!
x; // returns >  [1,2,3, -2: cat];

also:
x['chicken'] = 'cluck';
x.chicken // returns   'cluck';

===================================================================
	       * Object-Oriented Programming in JS
===================================================================
- Recall pillars of OOP
	Absraction
	Polymorphism
	Inheritence
	Encapsulation.

~~~~~~~~~~~~~~~ Inheritance in JavaScript ~~~~~~~~~~~~~~~~~~~~~~~~~
 -- Inheritance can't work like Java. There are no classes.
Java features classical inheritance. Javascript does not have
classes, so it cannot use classical inheritence. Javascript, instead,
uses prototypal inheritance. 
 -- Prototypal inheritence is objects inheriting from other objects. 

-- Objects have a prototype reference to the parent object, generally
with the __PROTO__ field. When we try to access any member that is
not defined on the current object, it attempts to recursively find 
it in the _PROTO__ chain. 

-- The __PROTO__ field is exposed to us so we can easily see it and
 modify it.
-- The old way of extending an object would be to use object.create()

  const Person = {
	firstName: '',
	lastName: '',
	printName: function() {
		console.log(`${this.firstName}  ${this.lastName}`)
	}
  }
  const Abby = object.create(Person);

  abby.__proto__ === Person << true;


  abby.firstName //returns: ''
(If browser doesnt find the first name on Abby, it goes to the 
Proto and giver her that name.)

  Person.firstName = 'nameless'
  abby.firstName //returns 'nameless' 
 		//the proto linked to updated person

-- You can change objects however by changing the __proto__
	const Dog = {
		firstName = 'Spot',
		speak: function() {console.log('bark')}
	}
	abby.__proto__ = Dog

-- You can have objects extend other objects as well.
	let otherAbby = object.create(abby);

-- Can't have cyclic inheritence.
	a.__proto__.__proto__ = a; 
	//would not work

==> Can have constructors 

  const Dog = function(name, speak) {
	this.name = name;
	this.speak = speak;
  }
  let fido = new Dog('fido',() =>console.log('bark'));


//ES6 'classes' are really just an organized constructor function.
    class Chicken{
	speak(){
		console.log('bawk');
	}

	constructor(feathers,eggs){
		this.feathers = feathers;
		this.eggs = eggs
	}
    }
    const cluck = new Chicken(1000,2);
    cluck.speak();

// NOTE the constructor() method is a special keyword to actually
// create a constructor for that object!!

==> Review:
- Java: classical inheritence (class based)
- JavaScript: prototypal inheritence (prototype based)
	-- objects extend other objects, NOT classes.
-- "class" in javascript is actually just a constructor function.
 Know what a constructor function is.


==>NOTE:
ES6 stands for ECMA-SCRIPT6 and has a preffered way to do things:
http://es6-features.org/#DefaultParameterValues
HOWEVER: Internet explorer doesn't support ES6 JS.

~~~~~~~~~~~~~~~~~~~~ Polymorphism In JS ~~~~~~~~~~~~~~~~~~~~~~~~~~~
Many forms... 
In java: Overloading and Overriding.
In JavaScript: 	
	Overridding - You certainly can because the program looks through from you object up the protos. You can reassign what a keyword does, from function to field. 
Overriding lworks like normal. Child object can define wheir own implementations for functionswith the same naame as the parent. Calling these functionswill use the child function, because its nearer in the protochain.

	Overloading - Can be done with defaults. 
1. Default parameter values
2. Extended parameters (var args)

	Functions in javascript don't care what you pass to them. We cannot assign two different functionsto the same object with the same name. Overloading like java in'st possible, but you can include internal logic to adapt to different parameters.

su(2)(3) -> 5
sum(2,3) -> 5

let sum = function(x,y) {
	if(y===undefined){
		return (z) => x + z;
	} else {
		return x + y;
	}
}

We can't have funtion owverloading in the same sense as Java, however we can adapt functionsto handle varying amounts of arguments internally.

Use arrow functions in general. Easiest to see who calls the function that way. 

-- Abstraction  : None in JavaScript.

-- Encapsulation : "A black box"
	Hiding Data.
In java, encapsulation is created with access modifiers. Getters and setters allow access to restricted methods/fields.

- NO access modifiers in JavaScript
	-this makes encasulation tricky.

Generally, over the years, encapsulation is implemeted using closures. Closures are a language feature, which is defined as fields defined within a function accessible from an inner function being available after the outer function has returend.

//JavaScript "Getters":
let outer = function(){
	let x = 10;
	let inner = function() {
		console.log(x)
	}
	return inner();
}
let myX = outer(); 	//now myX is a function printing 10.
let myX();		//Prints 10!

//Javascript "Getters & Setters"
let outer = function(){
	let x = 10;
	return {
		get: () => x,
		set: (y) => x = y
	};
};

let x = outer();
x.set(10);
x.get(); // returns 10.

// This IS a JavaScript FEATURE.
// It essentially holds onto the value placed into it. 
// Practice the supplied answer -- be able to describe Closures
You are able to encapulate them or access them outside of the function in which they're defined. 

Language feature ddefined as function which deifnes felds and returns a function which acessesthoas fields and the firleds stay alive becase they are acessible from a dlecalred function. You can' "hold on" to some values in memory..

// Jvascript developers don't need encapsulation, really.


//Something is wrong with this ... Double check it ** 
class MyObject {
	// "Private" fields are started with underscores.
	_myPrivateField;

	get myPrivateField(){
		return _myPrivateField;
	}
	set myPrivateField(f){
		this._myPrivateField = f; 
		//Functionally built into the langugage.
	}

	constructur(field){
		this._myPrivateField;
	}
}

"this" keywords are build into the language. 
Functions defined with the get and set keywords can be treated like fields:

y = new MyObject(5);

y.myPrivateField

==> No abstract classes in JavaScript. No real use. No plymorphism.
	We can't use parent class references and get child implementations. 



======================================
Functinos in JavaScript are "first-class citizens"
Meaning: 
Functions in JS are treated like fields, with the ability to be 
assigned and passed. Functions can be passed. They can be assigned,
 they can be reassigned, and they can be returned.

Callback functions - a function being called by another function

	const myFunction = function() {
		console.log('Done!');
	}
	setTimeout(myFunction, 1000)

Did we call the function?
NO. We DEFINED myfunction and CALLED setTimeout

Example of how a callback function might be utilized:

	Const otherFunction = function(f) {
		f();
	}

otherFunction(myFunction);

========> ENHANCED FOR LOOP IN JS

for(let e of myArr) {
	..
}
============

==>API and fetch: 

const getData = async function() {
    /**
     * Using Fetch
     */
    const url = 'https://www.anapioficeandfire.com/api/books/1';
    const response = await fetch(url);
    let data = await response.json();
    console.log(data);
    document.getElementById('title').innerText = data.name;

    for(let url of data.povCharacters){
        const charResponse = await fetch(url);
        const charData = await charResponse.json();
        const li = document.createElement('li');
        li.innerText = charData.name;
        document.getElementById('character-list').appendChild(li);
    }
}

==> XHR - AJAX (Asynchronous JavaScript and XML)
*****************************************************
Know how to use XHR (or at least talk about fetch)
*****************************************************

  XmlHttpRequest
 
 Asynchronous JavaScript and XML

Predates the fetch API and was the way we made HTTP requests prior 
to fetch, and still is in wide use today.


Restful (?) means your response sends a link to where 
you can get more information

const xhrExample = function() {
    const url= 'https://www.anapioficeandfire.com/api/characters/148';

    const xhr = new XMLHttpRequest();

    console.log(xhr.readyState); //0. unopened

    //must use event listeners to interact with xhr
    //This does not SEND the request
    xhr.open('get', url);
    console.log(xhr.readyState); //1. Opened
    //Defines evens prior to sending request so the
    // listeners are ready before the even happens
    //2. Headers_recieved
    //3. Loading
    //4. Done
    xhr.addEventListener('readystatechange',() => {
        console.log(xhr.readyState);
        if (xhr.readyState == 4) {
            //do stuff. 4 means DONE.
            // can be used if you need to check the transition from loading ot not loading ect like you need to check for na error. 
        }
    })

    xhr.addEventListener('loadend', () => {
        //JSON.parse converts STRING to JSON object
        //JSON.strinfify does the opposite
        console.log(JSON.parse(xhr.response));
    });
    //Send request
    xhr.send();
}

xhrExample();


=================================================================
XML in Java
ML still works on a dom. use a dom parser.
** Know the difference, you dont have to know HOW to do it in code **

DOM requires us to remember the entire DOM tree 
nice but has a lot of overhead.
DOM maintains entire DOM obj ect in memory at once. This may not be possible for sufficiently large XML documents.


SAX is event-based. SAX parses the XML and raises events upon encountering elments. SAX is faster than DOM, but utilization is somewhat more complicated, and the DOM itself isnt persisted in memory.
The structure is'nt kept. You just are able to react to events.
Benefit - you dont have to keep the whole thing in memoy. 
It can work on very large XMLs 
--Implementation is "more complicated" than XML, but not too bad.

JAXB - java architecture for xml binding. meant to be higher level. we marshal the xml (take it and convert ot java object.) 
Then we can work with in a more normal fashion. Essentially represent java object state in xml in the same way serialization worked.
- data format like JSON for recieving and parsing data from an API. 
Converts object state to data in this way.

=================================================================
Singleton
=================================================================
SIngleton design pattern - tool we use when we have some object and class where we only need one instance of it. Never will need more.
Singleton -> class where only 1 object will ever be necessary.
IS utilitarian things or singular things.. 
	IE scanner or database connection.

Good if you need something more object-based.
 Good for database managing objects/external resources
 - Especially multi-threading

class Singleton {
	private static Singleton = new Singleton();
	private Singleton(){
		//Instantiaets object
 	}
	public getSingleton(){
		return singleton;
	}
}
 
================================================================
			Servelets
================================================================
Eclipse >> Window >> Show Perspective >> other >> Java EE

- Show your problems tab (window > show view > other > problems)

Server tab >> new server

Server type = tomcat9

...

When done, right click server > Start.

Note tomcat just has console text in red.

In browser : localhost:8080
Now you can see local server is up and running.


==> Creating the porject
New Maven Project
--> NOT a simple project

On next page: chose webapp option 

Group :com.revature
ID: project name

Starts with problem, need to configure this. 
Right click project, Properties
Project Facets dropdown

Check dynamic web modules,

Runtimes tab, Check apche tomcat


Need a file that tells the server where to look in the project for the servlets (classes)

==> New folder structure
To create a new file, you need to go to the nromal main folder and create a java folder ( a folder named java )

Create class in java
package com.revature.servlets


==> Servlet Hierarchy:
Starts with interface:	Servlet		//interface, no methods
Implemented by:		GenericServlet	//handles responses/request
Extended by:		HttpServlet	//imp. by oracle (javacorelib)
Extended by:		DefaultServlet	//apache tomcat specific
Extended by:		You

Class MyClass extends DefaultServlet

Override method:
 service(httpServletRequest request, HttpServletResponse response) throws ServletException, IOException

KNOW that service throws ServiceException and IOException



webapp > web-inf > web.xml
Press source ( ignore design stuff )
==> If you make ANY mistake in the XML, it wont run the server at all
==> within the <web-app> tag:
  <servlet>
 	<servlet-name>hello</servlet-name>
  	<servlet-class>
		com.revature.servlets.HelloWorldServlet
	</servlet-class>
  </servlet>


  <servlet-mapping>
  	<servlet-name>hello</servlet-name>
  	<url-pattern>/hello</url-pattern>
  </servlet-mapping>
  

Right click server tab. Add and Remove.
Put the servlet you want in the configured side.
This is us giving the project to Tomcat.

Double click server to get overview.
Go to modules tab to see mapping for project.

Start server (see if it starts)

localhost:8080/ServletExample/hello

--> If you get an error, look in your console in eclipse!

In the XML file, you can change the URL pattern to:

  	<url-pattern>/hello/*</url-pattern>
and it'll let you type stuff at the end of the URL


==> Service (in an HttpServlet) is a method used to delegate requests to an appropriate handler method based on the HTTP method utilized to make the request.

HTTP Method    Handler Method   Crud Operation   SQL
GET 	->	 doGet		read		SELECT
POST	->	 doPost		create		CREATE
PUT 	->	 doPut		update		UPDATE
DELETE	-> 	 doDelete	delete		DELETE

doGet override can be used if service isn't there.
If you override BOTH, your doGet won't automatically come up. 

Can use 
super.service(request,response);

---------------
Some stuff here
-----------
The lifecycle of a servlet has 2 steps:
1. init - Initializing the servlet - Called once
2. service - handling a request - once per request
3. destroy - end of servlet lifecycle(shut down) - called once/never
































