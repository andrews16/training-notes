====================================================================
				HTML
====================================================================
- HTML stands for HyperText Markup Language 
- HTML5 (newest versiaon) maintained by W3C WorldWideWeb Consortium.
HTML is a symantic language used to describe content.
HTML is for browsers.
Tag is a structure.
Element is the actual representation of the tag and content.
Structure of HTML Document:
<!DOCTYPE html>
<html>
 <head></head>
 <body> </body> 
</html>
Rules : 
- Tags should be void, self-closing, or closed. 
- If tag is opened within another tag, it must be closed before another tag closes.

Attributes - Details about the tag and value.
Examples: 
src = "url" Loads external resource
type, class, id, width, height, href

DOM - Document Object Model
Tree Structure

			html
			 |
  .-------------------------------------.
  |					|
 head 	                               body
  |          	.---------------------------------------.
 meta		|			|		|
              header          	     article          footer 

        h1      nav       header  section    section div
                        ol       h2 p1   h3 p p p  
                   li li li
 
CSS also operations on this tree structure. This is how it knows which elements to select as children.
body nav {} //searches the body for navs underneath it to affect.

=> Text
h1 : header is a primary element used to describe main header regardless of HOW we want it displayed.
h2-h6 are subheadings
p : paragrpah
strong : increase weight of line
em : italics
=>Lists
ol : ordered (numbered) lists
ul : unorderd list
	li : list item (nested within list)
dl : dictionary list
	dt: definition text
=> Table
table
	thead (semantic)
	tbody (semantic)
	tr
		th
		td
=> a (anchor)	<a href="url">Link </a>
=> img (image)	<img src="url">
=> script (javascript) 
	<script src="url"></script> or <script>JS</script>
=> link <link href="css sheet" ref="stylesheet">
=>Arbitrary structures (No semantic meaning)
	- Only use if you have no better way to describe the content
	- IE if structure is only for visual reasons.
div : Block
span : Inline block
=> head
	Link
	meta
	title
=> Input
form Group of inputs that would be sent together.
	<form method="" >--"get" or "post"
<fieldset>
	<input type = "..." >
types : text, button, color, number, check, radio, select, datepicker, password, hidden,

CSS:
Cascading Stylesheet
Can provide styling rules inline, in style tag, or in a link(extenal)
Best to use as external
Selector{ property:value;}
	a {  
		 color : blue; 
	}

1. Tag -> h1 {}
2. Class -> .someClass{}
3. Id -> #someId{} 


Selector : 
.class1 .class2{}  selects all class2 in any class1
.class2,class1{} both class1 and 2
.class1 > class 2{} direct descentant
.class1.class2{} selects only elements with BOTH classes

==>display
block: by default fills width, creating block on its own line
inline: diplays on a baseline by default only large enoug ht ofill contents. Can be chained together(potentially changing the baseline)
flex: Used to align items/show them in particular ways. 
 inline flex, inline-block

Box model
 _ _ _ _ _ _ _ _ __ _ _ __ _ _ _ _ 
|_________________________ Margin|
|| ________________ Border|      |
||| _______ Padding|      |      |
||||Content|       |      |      |
||||_______|       |      |      |
|||________________|      |      |
||________________________|      |
|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |

Units of size:
%, px, em, rem, vh, vw, vmin, vmax

Colors:
Literal - (blue, red, ect)
hex - #RRGGBB with each character being 0-f representing 256 vals
rgb / rgba - (n,n,n{,0 <= a <= 1}) where n = [0,255]
hsl([0,255],%,%);


------- Vocabulary -------
Tag - keyword used as syntax to organize and label types of content
      on a page
    - Tags are contained within right angle brackets < and >
    - Beginning tags include the keyword and may include other
      properties.
    - End tags are created with the tag name in angle brackets
      preceede with /
    <tag property="value"> content </tag>
Self-closing Tags - Do NOT need closing tags. 
       Examples: <img> <input> <br> <hr>
        TRIVIA - you used to be told to use <br /> to signify the end
	of self-closing tags before 2009 when they threw out XHTML 
	guidelines
Element - A beginning tag, matching end tag, and the content between.
Attribute - a property/value pair given to an HTML element.
     <tag attribute> Content </tag>
      Attribute syntax is property="value"
Property - keyword describing characteristic an element may have
Value - the assignment given to a property
Server - centralized computer which manages website or application 
       by sending information to client and processing requests
----- HTML Elements ------
+ Heading-Related tags
  <heading> </heading> 
  Syntax tag to describe which part of the document is the heading
  <h1> <h2> ... <h6>
  h1 is a main heading
  Proceeding h#s are subheadings
  By default, h1 has the largest sized font, and the font size decreses

+ List-Related Elements
  <ul>  Unordered List (Not numbered/Bulleted list)
  <ol>  Ordered List (Numbered List)
  <li>  List Item

+ Basic HTML Requirements
<!DOCTYPE html5>          
<html>
   <head> .. </head>
   <body> .. </body>
</html>

+DOCTYPE tells the browser it is getting an HTML page.
         This is not required always - a browser will "guess" usually that 
          a file is html correctly - but is proper to use it.
<HTML>   element contains all other HTML elements
<head>   Contains page metadata such as the tile of the page, CSS scripts to link,          and somtimes a description to give search engines. 
         This isn't required to have information in it.
         <title>Page Title</title> is USUALLY the bare minimum, but isn't required.
<body>   Contains the visible content of the page in the view window.

+ <div> and <span> 
 <div> is a block element that may have arbitraty content.
       In HTML5, usually <div>s are replaced with more descriptive Semantic elements
  <span> is an inline-block element by default

-- BLOCK elements by default take up 100% the width 
         of their parent containing element.
-- INLINE-block elements stay in line with the text around it, 
       by default taking up only as much space as the content inside


+ Semantic Elements
   Semantic elements are blocks to label the content and for styling purposes.
	Examples:
	<header> , <main> , <footer>
	<section> , <article> , <summary>
	<nav>

+ Table-related Elements
  Tables are formatted, generally, as follows:
<table>
   <tr>
     <td> </td>
     <td> </td>
   </tr>
   <tr>
     <td> </td>
     <td> </td>
   </tr>
</table>

	<table> is the element declaring there will be a table.
	<tr> signifies a table row
	<td> signifies cell - table DATA - within the row from left to right.
	<th> is a table head cell which formats a cell

TRIVIA : Other table elements (probably youll never need):
<thead> <tbody> <tfooter>  Sematic elements to organize a table.
<caption> Place between the final </tr> and </table> to give it a caption
          By default 

==========================
         CSS
==========================
CSS = Cascading Style Sheet used to stylize HTML elements.
+ Current/Newest version : CSS4
    We have been using CSS3 (it is most popular now)

----- Vocabulary ---------
Selector - The element within the HTML you are selecting to stylize
         3 types of selectors:
	  1. Tags
	  2. Class
	  3. ID
Class - identify a group of elements on a page -- can be used mutiple times
	Elements can have multiple classes.
	In CSS you select by class with .ClassName
ID  - Identifies a specific element - each ID should only be used once.
	In CSS you select ids with #IdName
** You tell an element which class and or ID it has (if any) in the HTML.
+ How to insert CSS?
 1. Inline CSS - as a property to the HTML
    <tag style="attribute:value;
 2. Internal - usally placed in the <head>, but work anywhere.
    - CSS Contained by <style> .. </style> tags
 3. External stylesheets
    Must use HTML tag link to include external stylesheet:
<link href="./css.css" ref="stylesheet" type="text/css">

  Note above is default order of priority for CSS styling.
  You may also use !important to put a specific style to the top 
     of the priority list. For example:
	p {
    	   color: red !important;
	}

+ Colors
Main ways to identify colors:
  1. name  -- IE red, black
  2. Hexadecimal -- #RRGGBB
      RR GG and BB are red, green, or blue values 
      from 000000-ffffff (0-9 then a-f for each digit)
      00-ff corresponds to an RGB value of 0 to 255.
  3. RBG -- rgb(100, 100, 100)
      Numbers are R G B values of 0 to 255.
  4. RGBA -- rgba(100,100,100, .5)
      First 3 are the same as RGB, but the third value is ALPHA
      Alpha is an modified from 0 to 1 corresponding to a percent of opacity

+ The Box Model
 The box model describes layers of space around the content which can be stylized.
 _ _ _ _ _ _ _ _ __ _ _ __ _ _ _ _ 
|_________________________ Margin|
|| ________________ Border|      |
||| _______ Padding|      |      |
||||Content|       |      |      |
||||_______|       |      |      |
|||________________|      |      |
||________________________|      |
|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |

Margin is the outer layer, it is the space between one element and the next.
    Margins are vertically collapsable, meaning two blocks with margins, 
    one  directly above the other, 
    will have the distance of the largest margin of the two between borders.
Borders is the layer between the margin and content,
    usually the area what has a border, if specified.
Padding is the space between the content and the border.

+ Box-sizing
Typically, the width and height of a block are defined by the content.
   Padding, border, and margin are added on top of that.
The property box-sizing can specify if you want a height/width property
to be a "content-box" or a "border-box"

+ Selectors
  HINT: the type of element closest to the braces 
        is usually the one that will be stylized.

[space] "descentant of the element to stylize"
         .class p {};    will stylize all P that are in blocks with class .class
                      even if they are further nested in other blocks inside 
		      a main block with class .class


  >     "direct parent of the element to stylize"
         nav > a {};    is "nav, the parent of the element to stylize, a"
                   so this will stylize all a that are direct children of nav

  ,     "and"
         div,span,header{};    will stylize div, span, and header.

tag.class{}    will stylize tags with the class 'class'
tag#ID{}       will stylize tags with the ID 'ID'
 
+ Forms
Basic Outline of forms:
<form>         
      <label for="input1">Input One </label>
      <input name="input1" type="number" />
      <label for="input2">Input Two </label>
      <input name="input2" type="Text" />
      <input type="submit" value="Go!">
</form>

	Form tag organizes groups and inputs. 
  It tells the browser that the contained inputs and submit button 
  are all related and should be set to the server at the same time.

  Forms are blocks and can have attributes such as width, height, and background.
  Elements that are typically in forms include:
<button> <label> <input> <fieldset>

+ Variables

To use variables, right create them with the .root selector. 
Variable names start with "--"
.root{
	--text-color:blue;
	--div-bg:yellow;
}

To use them later, use var(--name)

div{
	color: var(--text-color);
	background-color:var(--div-bg);
}


===================================================================
Bootstrap
===================================================================
Getting started: 
http://getbootstrap.com/docs/4.1/getting-started/introduction/

Components : Little things you can use by using their code samples.
Alerts : Text that you can have pop up with optional close buttons.
Carousel : Slide images or things, may includes arrows to switch left/right, captions, different fades.
Buttons : Generally nices looking for buttons.
Navbar : Basic with dropdowns
Cards : Very common tool (image with text)

Layout >> Grid:
	- Built on flexbox to be more responsive.
	- Create a container class.
	- inner div specified directly.
	- Inner inner is the content.

In flexbox, page is gridded in 12ths.
<div class="container">
        <div class="row">
            <div class="col-6"></div>
            <div class="col-2"></div>
            <div class="col-4"></div>
        </div>
        <div class="row">
            <div class="col-1"></div>
            <div class="col-10"></div>
            <div class="col-1"></div>
        </div>
        <div class="row">
            <div class="col-4"></div>
            <div class="col-4"></div>
            <div class="col-4"></div>
        </div>
    </div>

Bootstrap Forms are quite common now... Most modern websites user bootstrap or Google Material Design.

Modals - used a lot for ads (cover streen until it is taken care of)  such as terms of conditions.

** QC Will ask about the grid in Bootstrap.




===================================================================
			* Javascript
===================================================================
 ~~~~~~~~~~~~~~~~~~~~~~~~ Truthy-falsey ~~~~~~~~~~~~~~~~~~~~~~~~~~
values in Javascript is the idea that every value can be evaluated for truthiness. This means nay value of any time can be utilized in an if statement, a logical argument, ect.
- Most values are considered "truthy", but certain values are falsy.

Falsy:
	"" (empty string), 0, null, NaN, undefined

- We can utilize these conditional statements in assignment.
The variable will assign the VALUE that made the difference in the result. 

const y = 0 || x;
		 y = x; << result
const z = NaN && x; 
		z = NaN; << result

>> Becomes the final value it checks. 
>> Useful to resolve if something might be null.

-- Boolean expressions in JavaScript don't necessarily evaluate to a true or false value, but instead evaluate to the value in the expression that made the difference in the resulting logical result. The logic of this follows short circuit logic closely.

==> Template Literals
ES6 Feature of JavaScript. They are used for formatting strins, and are often used in place of situations where you might be tempted to concatenate complicated strings or otherwise utilize complicated string literals.

const person = {
	firstName : 'Abby',
	lastName : 'Adams',
	age : 22
};

//We want to print out "my name is Abby adams and I'm 22 years old.
const str = "My name is " + person.firstName + " " + person.lastName + " and I am " + person.age + " years old";
console.log(str);

OR USE template literals. Allow for simpler varialbe injection without breaking the string.
let template = `` //<< NOT SINGLE QUOTES, theyre backticks
template = `My name is ${person.firstName} 
${person.lastName} and I'm ${person.age}
 years old.`

// Template literals ALLOW YOU to throw line breaks in there.
// Break provides ACTUAL linebreak. You can escale that with a single backslash where the lines are:
template = `My name is ${person.firstName} \
${person.lastName} and I'm ${person.age}\
 years old.`

==> 
Arays are actually type of objects. 

x = [1,2,3];
x[-2] = 'cat';
^ Is totally OK declaration.

returns: 
x > returns >  [1,2,3, -2: cat];

also:
x['chicken'] = 'cluck';
x.chicken > returns >  'cluck';

=======================================================
Object oriented programming

Abrstaction
P{olymorphism
Inheritence
Encapsulation.

Inheritance in JavaScript
Inheritance can't work like Java. There are no calsses .java features classical inheritance. Javascript does not have classes, so it cannot use classical inheritence. Javascript, instead, uses prototypal inheritance. Prototypal is the principle of objects inheriting from other objects. 

objects have a prototype reference to the parent object, generally with the __PROTO__ field. when we try to access any member that is not defined on the current object, it attempts to recursively find in it the _PROTO__ chain. 

The __PROTO__ field is exposed to us so we can easily see it and modify it.
The oldschool was of extended an object would be to use object.create()

const Person = {
	firstName: '',
	lastName: '',
	printName: function() {
		console.log(`${this.firstName}  ${this.lastName}`)
	}
}
const Abby = object.create(Person);

abby.__proto__ === Person << true;


abby.firstName >returns> ''
<<If it doesnt find the first name on Abby, it goes to the Proto and giver her that name.

Person.firstName = 'nameless'
abby.firstName >returns> 'nameless' //the proto liked to updated person

==> You can change objects however by changing the __proto__
	const Dog = {
		firstName = 'Spot',
		speak: function() {console.log('bark')}
	}
	abby.__proto__ = Dog


==> You can have objects extend other objects as well.
	let otherAbby = object.create(abby);

==> Can't have cyclic inheritence.
	a.__proto__.__proto__ = a; //<< would not work, you can have constructors


const Dog = function(name, speak) {
	this.name = name;
	this.speak = speak;
}
let fido = new Dog('fido',() =>console.log('bark'));


//ES6 'classes', really just an organized constructor function.
class Chicken{
	speak(){
		console.log('bawk');
	}

	constructor(feathers,eggs){
		this.feathers = feathers;
		this.eggs = eggs
	}
}
==> NEW keyword 
const cluck = new Chicken(1000,2);
cluck.speak();

Java: calssical inheritence
JavaScript uses Prototypal inheritence, objects extend other objects, NOT classes.
the "class" in javascript is actually just a constructor function. Know what a constructor function is. You just need to assign stuff with this. Pretty basic. 

JavaScript Object system is based on prototypes, not classes. 

ES6 stands for ECMA-SCRIPT6 and has a preffered way to do things:
http://es6-features.org/#DefaultParameterValues
HOWEVER: Internet explorer doesn't support ES6 JS.

==> Polymorphism. 
Many forms... 
In java: Overloading and Overriding.
In JavaScript: 	
	Overridding - You certainly can because the program looks through from you object up the protos. You can reassign what a keyword does, from function to field. 
Overriding lworks like normal. Child object can define wheir own implementations for functionswith the same naame as the parent. Calling these functionswill use the child function, because its nearer in the protochain.

	Overloading - Can be done with defaults. 
1. Default parameter values
2. Extended parameters (var args)

	Functions in javascript don't care what you pass to them. We cannot assign two different functionsto the same object with the same name. Overloading like java in'st possible, but you can include internal logic to adapt to different parameters.

su(2)(3) -> 5
sum(2,3) -> 5

let sum = function(x,y) {
	if(y===undefined){
		return (z) => x + z;
	} else {
		return x + y;
	}
}

We can't have funtion owverloading in the same sense as Java, however we can adapt functionsto handle varying amounts of arguments internally.

Use arrow functions in general. Easiest to see who calls the function that way. 

-- Abstraction  : None in JavaScript.

-- Encapsulation : "A black box"
	Hiding Data.
In java, encapsulation is created with access modifiers. Getters and setters allow access to restricted methods/fields.

- NO access modifiers in JavaScript
	-this makes encasulation tricky.

Generally, over the years, encapsulation is implemeted using closures. Closures are a language feature, which is defined as fields defined within a function accessible from an inner function being available after the outer function has returend.

//JavaScript "Getters":
let outer = function(){
	let x = 10;
	let inner = function() {
		console.log(x)
	}
	return inner();
}
let myX = outer(); 	//now myX is a function printing 10.
let myX();		//Prints 10!

//Javascript "Getters & Setters"
let outer = function(){
	let x = 10;
	return {
		get: () => x,
		set: (y) => x = y
	};
};

let x = outer();
x.set(10);
x.get(); // returns 10.

// This IS a JavaScript FEATURE.
// It essentially holds onto the value placed into it. 
// Practice the supplied answer -- be able to describe Closures
You are able to encapulate them or access them outside of the function in which they're defined. 

Language feature ddefined as function which deifnes felds and returns a function which acessesthoas fields and the firleds stay alive becase they are acessible from a dlecalred function. You can' "hold on" to some values in memory..

// Jvascript developers don't need encapsulation, really.


//Something is wrong with this ... Double check it ** 
class MyObject {
	// "Private" fields are started with underscores.
	_myPrivateField;

	get myPrivateField(){
		return _myPrivateField;
	}
	set myPrivateField(f){
		this._myPrivateField = f; 
		//Functionally built into the langugage.
	}

	constructur(field){
		this._myPrivateField;
	}
}

"this" keywords are build into the language. 
Functions defined with the get and set keywords can be treated like fields:

y = new MyObject(5);

y.myPrivateField

==> No abstract classes in JavaScript. No real use. No plymorphism.
	We can't use parent class references and get child implementations. 



======================================
Functinos in JavaScript are "first-class citizens"
Meaning: 
Functions in JS are treated like fields, with the ability to be 
assigned and passed. Functions can be passed. They can be assigned,
 they can be reassigned, and they can be returned.

Callback functions - a function being called by another function

	const myFunction = function() {
		console.log('Done!');
	}
	setTimeout(myFunction, 1000)

Did we call the function?
NO. We DEFINED myfunction and CALLED setTimeout

Example of how a callback function might be utilized:

	Const otherFunction = function(f) {
		f();
	}

otherFunction(myFunction);

========> ENHANCED FOR LOOP IN JS

for(let e of myArr) {
	..
}
============

==>API and fetch: 

const getData = async function() {
    /**
     * Using Fetch
     */
    const url = 'https://www.anapioficeandfire.com/api/books/1';
    const response = await fetch(url);
    let data = await response.json();
    console.log(data);
    document.getElementById('title').innerText = data.name;

    for(let url of data.povCharacters){
        const charResponse = await fetch(url);
        const charData = await charResponse.json();
        const li = document.createElement('li');
        li.innerText = charData.name;
        document.getElementById('character-list').appendChild(li);
    }
}

==> XHR - AJAX (Asynchronous JavaScript and XML)
*****************************************************
Know how to use XHR (or at least talk about fetch)
*****************************************************

  XmlHttpRequest
 
 Asynchronous JavaScript and XML

Predates the fetch API and was the way we made HTTP requests prior 
to fetch, and still is in wide use today.


Restful (?) means your response sends a link to where 
you can get more information

const xhrExample = function() {
    const url= 'https://www.anapioficeandfire.com/api/characters/148';

    const xhr = new XMLHttpRequest();

    console.log(xhr.readyState); //0. unopened

    //must use event listeners to interact with xhr
    //This does not SEND the request
    xhr.open('get', url);
    console.log(xhr.readyState); //1. Opened
    //Defines evens prior to sending request so the
    // listeners are ready before the even happens
    //2. Headers_recieved
    //3. Loading
    //4. Done
    xhr.addEventListener('readystatechange',() => {
        console.log(xhr.readyState);
        if (xhr.readyState == 4) {
            //do stuff. 4 means DONE.
            // can be used if you need to check the transition from loading ot not loading ect like you need to check for na error. 
        }
    })

    xhr.addEventListener('loadend', () => {
        //JSON.parse converts STRING to JSON object
        //JSON.strinfify does the opposite
        console.log(JSON.parse(xhr.response));
    });
    //Send request
    xhr.send();
}

xhrExample();


=================================================================
XML in Java
ML still works on a dom. use a dom parser.
** Know the difference, you dont have to know HOW to do it in code **

DOM requires us to remember the entire DOM tree 
nice but has a lot of overhead.
DOM maintains entire DOM obj ect in memory at once. This may not be possible for sufficiently large XML documents.


SAX is event-based. SAX parses the XML and raises events upon encountering elments. SAX is faster than DOM, but utilization is somewhat more complicated, and the DOM itself isnt persisted in memory.
The structure is'nt kept. You just are able to react to events.
Benefit - you dont have to keep the whole thing in memoy. 
It can work on very large XMLs 
--Implementation is "more complicated" than XML, but not too bad.

JAXB - java architecture for xml binding. meant to be higher level. we marshal the xml (take it and convert ot java object.) 
Then we can work with in a more normal fashion. Essentially represent java object state in xml in the same way serialization worked.
- data format like JSON for recieving and parsing data from an API. 
Converts object state to data in this way.

=================================================================
Singleton
=================================================================
SIngleton design pattern - tool we use when we have some object and class where we only need one instance of it. Never will need more.
Singleton -> class where only 1 object will ever be necessary.
IS utilitarian things or singular things.. 
	IE scanner or database connection.

Good if you need something more object-based.
 Good for database managing objects/external resources
 - Especially multi-threading

class Singleton {
	private static Singleton = new Singleton();
	private Singleton(){
		//Instantiaets object
 	}
	public getSingleton(){
		return singleton;
	}
}
 
================================================================
			Servelets
================================================================
Eclipse >> Window >> Show Perspective >> other >> Java EE

- Show your problems tab (window > show view > other > problems)

Server tab >> new server

Server type = tomcat9

...

When done, right click server > Start.

Note tomcat just has console text in red.

In browser : localhost:8080
Now you can see local server is up and running.


==> Creating the porject
New Maven Project
--> NOT a simple project

On next page: chose webapp option 

Group :com.revature
ID: project name

Starts with problem, need to configure this. 
Right click project, Properties
Project Facets dropdown

Check dynamic web modules,

Runtimes tab, Check apche tomcat


Need a file that tells the server where to look in the project for the servlets (classes)

==> New folder structure
To create a new file, you need to go to the nromal main folder and create a java folder ( a folder named java )

Create class in java
package com.revature.servlets


==> Servlet Hierarchy:
Starts with interface:	Servlet		//interface, no methods
Implemented by:		GenericServlet	//handles responses/request
Extended by:		HttpServlet	//imp. by oracle (javacorelib)
Extended by:		DefaultServlet	//apache tomcat specific
Extended by:		You

Class MyClass extends DefaultServlet

Override method:
 service(httpServletRequest request, HttpServletResponse response) throws ServletException, IOException

KNOW that service throws ServiceException and IOException



webapp > web-inf > web.xml
Press source ( ignore design stuff )
==> If you make ANY mistake in the XML, it wont run the server at all
==> within the <web-app> tag:
  <servlet>
 	<servlet-name>hello</servlet-name>
  	<servlet-class>
		com.revature.servlets.HelloWorldServlet
	</servlet-class>
  </servlet>


  <servlet-mapping>
  	<servlet-name>hello</servlet-name>
  	<url-pattern>/hello</url-pattern>
  </servlet-mapping>
  

Right click server tab. Add and Remove.
Put the servlet you want in the configured side.
This is us giving the project to Tomcat.

Double click server to get overview.
Go to modules tab to see mapping for project.

Start server (see if it starts)

localhost:8080/ServletExample/hello

--> If you get an error, look in your console in eclipse!

In the XML file, you can change the URL pattern to:

  	<url-pattern>/hello/*</url-pattern>
and it'll let you type stuff at the end of the URL


==> Service (in an HttpServlet) is a method used to delegate requests to an appropriate handler method based on the HTTP method utilized to make the request.

HTTP Method    Handler Method   Crud Operation   SQL
GET 	->	 doGet		read		SELECT
POST	->	 doPost		create		CREATE
PUT 	->	 doPut		update		UPDATE
DELETE	-> 	 doDelete	delete		DELETE

doGet override can be used if service isn't there.
If you override BOTH, your doGet won't automatically come up. 

Can use 
super.service(request,response);

---------------
Some stuff here
-----------
The lifecycle of a servlet has 2 steps:
1. init - Initializing the servlet - Called once
2. service - handling a request - once per request
3. destroy - end of servlet lifecycle(shut down) - called once/never
































